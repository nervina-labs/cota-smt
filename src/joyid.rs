// Generated by Molecule 0.7.3
#![allow(unused_imports)]
#![allow(dead_code)]
#![allow(clippy::if_same_then_else)]

use super::ckb_types::prelude::*;
use super::molecule::{self, prelude::*};
extern crate alloc;
pub use alloc::vec::*;
// these lines above are manually added

use super::common::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct LockScriptVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LockScriptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LockScriptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LockScriptVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for LockScriptVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        LockScriptVec::new_unchecked(v.into())
    }
}
impl LockScriptVec {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<Bytes> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> Bytes {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            Bytes::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        }
    }

    pub fn as_reader<'r>(&'r self) -> LockScriptVecReader<'r> {
        LockScriptVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LockScriptVec {
    type Builder = LockScriptVecBuilder;

    const NAME: &'static str = "LockScriptVec";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LockScriptVec(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LockScriptVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LockScriptVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct LockScriptVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LockScriptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LockScriptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LockScriptVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> LockScriptVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<BytesReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for LockScriptVecReader<'r> {
    type Entity = LockScriptVec;

    const NAME: &'static str = "LockScriptVecReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        LockScriptVecReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            BytesReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct LockScriptVecBuilder(pub(crate) Vec<Bytes>);
impl LockScriptVecBuilder {
    pub fn set(mut self, v: Vec<Bytes>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: Bytes) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = Bytes>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }

    pub fn replace(&mut self, index: usize, v: Bytes) -> Option<Bytes> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for LockScriptVecBuilder {
    type Entity = LockScriptVec;

    const NAME: &'static str = "LockScriptVecBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LockScriptVec::new_unchecked(inner.into())
    }
}
pub struct LockScriptVecIterator(LockScriptVec, usize, usize);
impl ::core::iter::Iterator for LockScriptVecIterator {
    type Item = Bytes;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for LockScriptVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for LockScriptVec {
    type IntoIter = LockScriptVecIterator;
    type Item = Bytes;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        LockScriptVecIterator(self, 0, len)
    }
}
impl<'r> LockScriptVecReader<'r> {
    pub fn iter<'t>(&'t self) -> LockScriptVecReaderIterator<'t, 'r> {
        LockScriptVecReaderIterator(&self, 0, self.len())
    }
}
pub struct LockScriptVecReaderIterator<'t, 'r>(&'t LockScriptVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for LockScriptVecReaderIterator<'t, 'r> {
    type Item = BytesReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for LockScriptVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SubKey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SubKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "smt_type", self.smt_type())?;
        write!(f, ", {}: {}", "sub_type", self.sub_type())?;
        write!(f, ", {}: {}", "ext_data", self.ext_data())?;
        write!(f, ", {}: {}", "reserved", self.reserved())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for SubKey {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        SubKey::new_unchecked(v.into())
    }
}
impl SubKey {
    pub const FIELD_COUNT: usize = 4;
    pub const FIELD_SIZES: [usize; 4] = [2, 6, 4, 20];
    pub const TOTAL_SIZE: usize = 32;

    pub fn smt_type(&self) -> Uint16 {
        Uint16::new_unchecked(self.0.slice(0..2))
    }

    pub fn sub_type(&self) -> Byte6 {
        Byte6::new_unchecked(self.0.slice(2..8))
    }

    pub fn ext_data(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(8..12))
    }

    pub fn reserved(&self) -> Byte20 {
        Byte20::new_unchecked(self.0.slice(12..32))
    }

    pub fn as_reader<'r>(&'r self) -> SubKeyReader<'r> {
        SubKeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SubKey {
    type Builder = SubKeyBuilder;

    const NAME: &'static str = "SubKey";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SubKey(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .smt_type(self.smt_type())
            .sub_type(self.sub_type())
            .ext_data(self.ext_data())
            .reserved(self.reserved())
    }
}
#[derive(Clone, Copy)]
pub struct SubKeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SubKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "smt_type", self.smt_type())?;
        write!(f, ", {}: {}", "sub_type", self.sub_type())?;
        write!(f, ", {}: {}", "ext_data", self.ext_data())?;
        write!(f, ", {}: {}", "reserved", self.reserved())?;
        write!(f, " }}")
    }
}
impl<'r> SubKeyReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub const FIELD_SIZES: [usize; 4] = [2, 6, 4, 20];
    pub const TOTAL_SIZE: usize = 32;

    pub fn smt_type(&self) -> Uint16Reader<'r> {
        Uint16Reader::new_unchecked(&self.as_slice()[0..2])
    }

    pub fn sub_type(&self) -> Byte6Reader<'r> {
        Byte6Reader::new_unchecked(&self.as_slice()[2..8])
    }

    pub fn ext_data(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[8..12])
    }

    pub fn reserved(&self) -> Byte20Reader<'r> {
        Byte20Reader::new_unchecked(&self.as_slice()[12..32])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SubKeyReader<'r> {
    type Entity = SubKey;

    const NAME: &'static str = "SubKeyReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SubKeyReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SubKeyBuilder {
    pub(crate) smt_type: Uint16,
    pub(crate) sub_type: Byte6,
    pub(crate) ext_data: Uint32,
    pub(crate) reserved: Byte20,
}
impl SubKeyBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub const FIELD_SIZES: [usize; 4] = [2, 6, 4, 20];
    pub const TOTAL_SIZE: usize = 32;

    pub fn smt_type(mut self, v: Uint16) -> Self {
        self.smt_type = v;
        self
    }

    pub fn sub_type(mut self, v: Byte6) -> Self {
        self.sub_type = v;
        self
    }

    pub fn ext_data(mut self, v: Uint32) -> Self {
        self.ext_data = v;
        self
    }

    pub fn reserved(mut self, v: Byte20) -> Self {
        self.reserved = v;
        self
    }
}
impl molecule::prelude::Builder for SubKeyBuilder {
    type Entity = SubKey;

    const NAME: &'static str = "SubKeyBuilder";

    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.smt_type.as_slice())?;
        writer.write_all(self.sub_type.as_slice())?;
        writer.write_all(self.ext_data.as_slice())?;
        writer.write_all(self.reserved.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SubKey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SubValue(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SubValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SubValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SubValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "alg_index", self.alg_index())?;
        write!(f, ", {}: {}", "pubkey_hash", self.pubkey_hash())?;
        write!(f, ", {}: {}", "reserved", self.reserved())?;
        write!(f, ", {}: {}", "padding", self.padding())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SubValue {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            52, 0, 0, 0, 20, 0, 0, 0, 22, 0, 0, 0, 42, 0, 0, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SubValue::new_unchecked(v.into())
    }
}
impl SubValue {
    pub const FIELD_COUNT: usize = 4;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn alg_index(&self) -> Uint16 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint16::new_unchecked(self.0.slice(start..end))
    }

    pub fn pubkey_hash(&self) -> Byte20 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte20::new_unchecked(self.0.slice(start..end))
    }

    pub fn reserved(&self) -> Byte9 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte9::new_unchecked(self.0.slice(start..end))
    }

    pub fn padding(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Byte::new_unchecked(self.0.slice(start..end))
        } else {
            Byte::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SubValueReader<'r> {
        SubValueReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SubValue {
    type Builder = SubValueBuilder;

    const NAME: &'static str = "SubValue";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SubValue(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubValueReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubValueReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .alg_index(self.alg_index())
            .pubkey_hash(self.pubkey_hash())
            .reserved(self.reserved())
            .padding(self.padding())
    }
}
#[derive(Clone, Copy)]
pub struct SubValueReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SubValueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SubValueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SubValueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "alg_index", self.alg_index())?;
        write!(f, ", {}: {}", "pubkey_hash", self.pubkey_hash())?;
        write!(f, ", {}: {}", "reserved", self.reserved())?;
        write!(f, ", {}: {}", "padding", self.padding())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SubValueReader<'r> {
    pub const FIELD_COUNT: usize = 4;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn alg_index(&self) -> Uint16Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint16Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn pubkey_hash(&self) -> Byte20Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte20Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn reserved(&self) -> Byte9Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte9Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn padding(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            ByteReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ByteReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SubValueReader<'r> {
    type Entity = SubValue;

    const NAME: &'static str = "SubValueReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SubValueReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint16Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte20Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte9Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        ByteReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SubValueBuilder {
    pub(crate) alg_index:   Uint16,
    pub(crate) pubkey_hash: Byte20,
    pub(crate) reserved:    Byte9,
    pub(crate) padding:     Byte,
}
impl SubValueBuilder {
    pub const FIELD_COUNT: usize = 4;

    pub fn alg_index(mut self, v: Uint16) -> Self {
        self.alg_index = v;
        self
    }

    pub fn pubkey_hash(mut self, v: Byte20) -> Self {
        self.pubkey_hash = v;
        self
    }

    pub fn reserved(mut self, v: Byte9) -> Self {
        self.reserved = v;
        self
    }

    pub fn padding(mut self, v: Byte) -> Self {
        self.padding = v;
        self
    }
}
impl molecule::prelude::Builder for SubValueBuilder {
    type Entity = SubValue;

    const NAME: &'static str = "SubValueBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.alg_index.as_slice().len()
            + self.pubkey_hash.as_slice().len()
            + self.reserved.as_slice().len()
            + self.padding.as_slice().len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.alg_index.as_slice().len();
        offsets.push(total_size);
        total_size += self.pubkey_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.reserved.as_slice().len();
        offsets.push(total_size);
        total_size += self.padding.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.alg_index.as_slice())?;
        writer.write_all(self.pubkey_hash.as_slice())?;
        writer.write_all(self.reserved.as_slice())?;
        writer.write_all(self.padding.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SubValue::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SubKeyVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SubKeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SubKeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SubKeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SubKeyVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        SubKeyVec::new_unchecked(v.into())
    }
}
impl SubKeyVec {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SubKey> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SubKey {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        SubKey::new_unchecked(self.0.slice(start..end))
    }

    pub fn as_reader<'r>(&'r self) -> SubKeyVecReader<'r> {
        SubKeyVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SubKeyVec {
    type Builder = SubKeyVecBuilder;

    const NAME: &'static str = "SubKeyVec";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SubKeyVec(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SubKeyVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SubKeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SubKeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SubKeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SubKeyVecReader<'r> {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SubKeyReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SubKeyReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        SubKeyReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SubKeyVecReader<'r> {
    type Entity = SubKeyVec;

    const NAME: &'static str = "SubKeyVecReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SubKeyVecReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SubKeyVecBuilder(pub(crate) Vec<SubKey>);
impl SubKeyVecBuilder {
    pub const ITEM_SIZE: usize = 32;

    pub fn set(mut self, v: Vec<SubKey>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: SubKey) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = SubKey>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }

    pub fn replace(&mut self, index: usize, v: SubKey) -> Option<SubKey> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SubKeyVecBuilder {
    type Entity = SubKeyVec;

    const NAME: &'static str = "SubKeyVecBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SubKeyVec::new_unchecked(inner.into())
    }
}
pub struct SubKeyVecIterator(SubKeyVec, usize, usize);
impl ::core::iter::Iterator for SubKeyVecIterator {
    type Item = SubKey;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SubKeyVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SubKeyVec {
    type IntoIter = SubKeyVecIterator;
    type Item = SubKey;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SubKeyVecIterator(self, 0, len)
    }
}
impl<'r> SubKeyVecReader<'r> {
    pub fn iter<'t>(&'t self) -> SubKeyVecReaderIterator<'t, 'r> {
        SubKeyVecReaderIterator(&self, 0, self.len())
    }
}
pub struct SubKeyVecReaderIterator<'t, 'r>(&'t SubKeyVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SubKeyVecReaderIterator<'t, 'r> {
    type Item = SubKeyReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SubKeyVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SubValueVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SubValueVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SubValueVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SubValueVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SubValueVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        SubValueVec::new_unchecked(v.into())
    }
}
impl SubValueVec {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SubValue> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SubValue {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SubValue::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SubValue::new_unchecked(self.0.slice(start..end))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SubValueVecReader<'r> {
        SubValueVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SubValueVec {
    type Builder = SubValueVecBuilder;

    const NAME: &'static str = "SubValueVec";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SubValueVec(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubValueVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubValueVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SubValueVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SubValueVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SubValueVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SubValueVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SubValueVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SubValueReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SubValueReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SubValueReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SubValueReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SubValueVecReader<'r> {
    type Entity = SubValueVec;

    const NAME: &'static str = "SubValueVecReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SubValueVecReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            SubValueReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SubValueVecBuilder(pub(crate) Vec<SubValue>);
impl SubValueVecBuilder {
    pub fn set(mut self, v: Vec<SubValue>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: SubValue) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = SubValue>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }

    pub fn replace(&mut self, index: usize, v: SubValue) -> Option<SubValue> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SubValueVecBuilder {
    type Entity = SubValueVec;

    const NAME: &'static str = "SubValueVecBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SubValueVec::new_unchecked(inner.into())
    }
}
pub struct SubValueVecIterator(SubValueVec, usize, usize);
impl ::core::iter::Iterator for SubValueVecIterator {
    type Item = SubValue;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SubValueVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SubValueVec {
    type IntoIter = SubValueVecIterator;
    type Item = SubValue;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SubValueVecIterator(self, 0, len)
    }
}
impl<'r> SubValueVecReader<'r> {
    pub fn iter<'t>(&'t self) -> SubValueVecReaderIterator<'t, 'r> {
        SubValueVecReaderIterator(&self, 0, self.len())
    }
}
pub struct SubValueVecReaderIterator<'t, 'r>(&'t SubValueVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SubValueVecReaderIterator<'t, 'r> {
    type Item = SubValueReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SubValueVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SubKeyEntries(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SubKeyEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SubKeyEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SubKeyEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "keys", self.keys())?;
        write!(f, ", {}: {}", "values", self.values())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SubKeyEntries {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        ];
        SubKeyEntries::new_unchecked(v.into())
    }
}
impl SubKeyEntries {
    pub const FIELD_COUNT: usize = 2;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn keys(&self) -> SubKeyVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SubKeyVec::new_unchecked(self.0.slice(start..end))
    }

    pub fn values(&self) -> SubValueVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SubValueVec::new_unchecked(self.0.slice(start..end))
        } else {
            SubValueVec::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SubKeyEntriesReader<'r> {
        SubKeyEntriesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SubKeyEntries {
    type Builder = SubKeyEntriesBuilder;

    const NAME: &'static str = "SubKeyEntries";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SubKeyEntries(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyEntriesReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyEntriesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().keys(self.keys()).values(self.values())
    }
}
#[derive(Clone, Copy)]
pub struct SubKeyEntriesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SubKeyEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SubKeyEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SubKeyEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "keys", self.keys())?;
        write!(f, ", {}: {}", "values", self.values())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SubKeyEntriesReader<'r> {
    pub const FIELD_COUNT: usize = 2;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn keys(&self) -> SubKeyVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SubKeyVecReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn values(&self) -> SubValueVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SubValueVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SubValueVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SubKeyEntriesReader<'r> {
    type Entity = SubKeyEntries;

    const NAME: &'static str = "SubKeyEntriesReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SubKeyEntriesReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SubKeyVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SubValueVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SubKeyEntriesBuilder {
    pub(crate) keys:   SubKeyVec,
    pub(crate) values: SubValueVec,
}
impl SubKeyEntriesBuilder {
    pub const FIELD_COUNT: usize = 2;

    pub fn keys(mut self, v: SubKeyVec) -> Self {
        self.keys = v;
        self
    }

    pub fn values(mut self, v: SubValueVec) -> Self {
        self.values = v;
        self
    }
}
impl molecule::prelude::Builder for SubKeyEntriesBuilder {
    type Entity = SubKeyEntries;

    const NAME: &'static str = "SubKeyEntriesBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.keys.as_slice().len()
            + self.values.as_slice().len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.keys.as_slice().len();
        offsets.push(total_size);
        total_size += self.values.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.keys.as_slice())?;
        writer.write_all(self.values.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SubKeyEntries::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SubKeyUnlockEntries(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SubKeyUnlockEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SubKeyUnlockEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SubKeyUnlockEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "ext_data", self.ext_data())?;
        write!(f, ", {}: {}", "alg_index", self.alg_index())?;
        write!(f, ", {}: {}", "subkey_proof", self.subkey_proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SubKeyUnlockEntries {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            26, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SubKeyUnlockEntries::new_unchecked(v.into())
    }
}
impl SubKeyUnlockEntries {
    pub const FIELD_COUNT: usize = 3;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn ext_data(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }

    pub fn alg_index(&self) -> Uint16 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint16::new_unchecked(self.0.slice(start..end))
    }

    pub fn subkey_proof(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SubKeyUnlockEntriesReader<'r> {
        SubKeyUnlockEntriesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SubKeyUnlockEntries {
    type Builder = SubKeyUnlockEntriesBuilder;

    const NAME: &'static str = "SubKeyUnlockEntries";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SubKeyUnlockEntries(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyUnlockEntriesReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SubKeyUnlockEntriesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .ext_data(self.ext_data())
            .alg_index(self.alg_index())
            .subkey_proof(self.subkey_proof())
    }
}
#[derive(Clone, Copy)]
pub struct SubKeyUnlockEntriesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SubKeyUnlockEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SubKeyUnlockEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SubKeyUnlockEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "ext_data", self.ext_data())?;
        write!(f, ", {}: {}", "alg_index", self.alg_index())?;
        write!(f, ", {}: {}", "subkey_proof", self.subkey_proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SubKeyUnlockEntriesReader<'r> {
    pub const FIELD_COUNT: usize = 3;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn ext_data(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn alg_index(&self) -> Uint16Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint16Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn subkey_proof(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SubKeyUnlockEntriesReader<'r> {
    type Entity = SubKeyUnlockEntries;

    const NAME: &'static str = "SubKeyUnlockEntriesReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SubKeyUnlockEntriesReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint16Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SubKeyUnlockEntriesBuilder {
    pub(crate) ext_data:     Uint32,
    pub(crate) alg_index:    Uint16,
    pub(crate) subkey_proof: Bytes,
}
impl SubKeyUnlockEntriesBuilder {
    pub const FIELD_COUNT: usize = 3;

    pub fn ext_data(mut self, v: Uint32) -> Self {
        self.ext_data = v;
        self
    }

    pub fn alg_index(mut self, v: Uint16) -> Self {
        self.alg_index = v;
        self
    }

    pub fn subkey_proof(mut self, v: Bytes) -> Self {
        self.subkey_proof = v;
        self
    }
}
impl molecule::prelude::Builder for SubKeyUnlockEntriesBuilder {
    type Entity = SubKeyUnlockEntries;

    const NAME: &'static str = "SubKeyUnlockEntriesBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.ext_data.as_slice().len()
            + self.alg_index.as_slice().len()
            + self.subkey_proof.as_slice().len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.ext_data.as_slice().len();
        offsets.push(total_size);
        total_size += self.alg_index.as_slice().len();
        offsets.push(total_size);
        total_size += self.subkey_proof.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.ext_data.as_slice())?;
        writer.write_all(self.alg_index.as_slice())?;
        writer.write_all(self.subkey_proof.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SubKeyUnlockEntries::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SocialKey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SocialKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SocialKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SocialKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "smt_type", self.smt_type())?;
        write!(f, ", {}: {}", "sub_type", self.sub_type())?;
        write!(f, ", {}: {}", "reserved", self.reserved())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for SocialKey {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        SocialKey::new_unchecked(v.into())
    }
}
impl SocialKey {
    pub const FIELD_COUNT: usize = 3;
    pub const FIELD_SIZES: [usize; 3] = [2, 6, 24];
    pub const TOTAL_SIZE: usize = 32;

    pub fn smt_type(&self) -> Uint16 {
        Uint16::new_unchecked(self.0.slice(0..2))
    }

    pub fn sub_type(&self) -> Byte6 {
        Byte6::new_unchecked(self.0.slice(2..8))
    }

    pub fn reserved(&self) -> Byte24 {
        Byte24::new_unchecked(self.0.slice(8..32))
    }

    pub fn as_reader<'r>(&'r self) -> SocialKeyReader<'r> {
        SocialKeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SocialKey {
    type Builder = SocialKeyBuilder;

    const NAME: &'static str = "SocialKey";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SocialKey(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialKeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialKeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .smt_type(self.smt_type())
            .sub_type(self.sub_type())
            .reserved(self.reserved())
    }
}
#[derive(Clone, Copy)]
pub struct SocialKeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SocialKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SocialKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SocialKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "smt_type", self.smt_type())?;
        write!(f, ", {}: {}", "sub_type", self.sub_type())?;
        write!(f, ", {}: {}", "reserved", self.reserved())?;
        write!(f, " }}")
    }
}
impl<'r> SocialKeyReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub const FIELD_SIZES: [usize; 3] = [2, 6, 24];
    pub const TOTAL_SIZE: usize = 32;

    pub fn smt_type(&self) -> Uint16Reader<'r> {
        Uint16Reader::new_unchecked(&self.as_slice()[0..2])
    }

    pub fn sub_type(&self) -> Byte6Reader<'r> {
        Byte6Reader::new_unchecked(&self.as_slice()[2..8])
    }

    pub fn reserved(&self) -> Byte24Reader<'r> {
        Byte24Reader::new_unchecked(&self.as_slice()[8..32])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SocialKeyReader<'r> {
    type Entity = SocialKey;

    const NAME: &'static str = "SocialKeyReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SocialKeyReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SocialKeyBuilder {
    pub(crate) smt_type: Uint16,
    pub(crate) sub_type: Byte6,
    pub(crate) reserved: Byte24,
}
impl SocialKeyBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub const FIELD_SIZES: [usize; 3] = [2, 6, 24];
    pub const TOTAL_SIZE: usize = 32;

    pub fn smt_type(mut self, v: Uint16) -> Self {
        self.smt_type = v;
        self
    }

    pub fn sub_type(mut self, v: Byte6) -> Self {
        self.sub_type = v;
        self
    }

    pub fn reserved(mut self, v: Byte24) -> Self {
        self.reserved = v;
        self
    }
}
impl molecule::prelude::Builder for SocialKeyBuilder {
    type Entity = SocialKey;

    const NAME: &'static str = "SocialKeyBuilder";

    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.smt_type.as_slice())?;
        writer.write_all(self.sub_type.as_slice())?;
        writer.write_all(self.reserved.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SocialKey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SocialValue(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SocialValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SocialValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SocialValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "recovery_mode", self.recovery_mode())?;
        write!(f, ", {}: {}", "must", self.must())?;
        write!(f, ", {}: {}", "total", self.total())?;
        write!(f, ", {}: {}", "signers", self.signers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SocialValue {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            27, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        ];
        SocialValue::new_unchecked(v.into())
    }
}
impl SocialValue {
    pub const FIELD_COUNT: usize = 4;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn recovery_mode(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }

    pub fn must(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }

    pub fn total(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }

    pub fn signers(&self) -> LockScriptVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            LockScriptVec::new_unchecked(self.0.slice(start..end))
        } else {
            LockScriptVec::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SocialValueReader<'r> {
        SocialValueReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SocialValue {
    type Builder = SocialValueBuilder;

    const NAME: &'static str = "SocialValue";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SocialValue(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialValueReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialValueReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .recovery_mode(self.recovery_mode())
            .must(self.must())
            .total(self.total())
            .signers(self.signers())
    }
}
#[derive(Clone, Copy)]
pub struct SocialValueReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SocialValueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SocialValueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SocialValueReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "recovery_mode", self.recovery_mode())?;
        write!(f, ", {}: {}", "must", self.must())?;
        write!(f, ", {}: {}", "total", self.total())?;
        write!(f, ", {}: {}", "signers", self.signers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SocialValueReader<'r> {
    pub const FIELD_COUNT: usize = 4;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn recovery_mode(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn must(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn total(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn signers(&self) -> LockScriptVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            LockScriptVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            LockScriptVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SocialValueReader<'r> {
    type Entity = SocialValue;

    const NAME: &'static str = "SocialValueReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SocialValueReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ByteReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ByteReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        LockScriptVecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SocialValueBuilder {
    pub(crate) recovery_mode: Byte,
    pub(crate) must:          Byte,
    pub(crate) total:         Byte,
    pub(crate) signers:       LockScriptVec,
}
impl SocialValueBuilder {
    pub const FIELD_COUNT: usize = 4;

    pub fn recovery_mode(mut self, v: Byte) -> Self {
        self.recovery_mode = v;
        self
    }

    pub fn must(mut self, v: Byte) -> Self {
        self.must = v;
        self
    }

    pub fn total(mut self, v: Byte) -> Self {
        self.total = v;
        self
    }

    pub fn signers(mut self, v: LockScriptVec) -> Self {
        self.signers = v;
        self
    }
}
impl molecule::prelude::Builder for SocialValueBuilder {
    type Entity = SocialValue;

    const NAME: &'static str = "SocialValueBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.recovery_mode.as_slice().len()
            + self.must.as_slice().len()
            + self.total.as_slice().len()
            + self.signers.as_slice().len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.recovery_mode.as_slice().len();
        offsets.push(total_size);
        total_size += self.must.as_slice().len();
        offsets.push(total_size);
        total_size += self.total.as_slice().len();
        offsets.push(total_size);
        total_size += self.signers.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.recovery_mode.as_slice())?;
        writer.write_all(self.must.as_slice())?;
        writer.write_all(self.total.as_slice())?;
        writer.write_all(self.signers.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SocialValue::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SocialKeyVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SocialKeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SocialKeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SocialKeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SocialKeyVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        SocialKeyVec::new_unchecked(v.into())
    }
}
impl SocialKeyVec {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SocialKey> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SocialKey {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        SocialKey::new_unchecked(self.0.slice(start..end))
    }

    pub fn as_reader<'r>(&'r self) -> SocialKeyVecReader<'r> {
        SocialKeyVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SocialKeyVec {
    type Builder = SocialKeyVecBuilder;

    const NAME: &'static str = "SocialKeyVec";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SocialKeyVec(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialKeyVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialKeyVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SocialKeyVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SocialKeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SocialKeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SocialKeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SocialKeyVecReader<'r> {
    pub const ITEM_SIZE: usize = 32;

    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }

    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SocialKeyReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SocialKeyReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        SocialKeyReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for SocialKeyVecReader<'r> {
    type Entity = SocialKeyVec;

    const NAME: &'static str = "SocialKeyVecReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SocialKeyVecReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SocialKeyVecBuilder(pub(crate) Vec<SocialKey>);
impl SocialKeyVecBuilder {
    pub const ITEM_SIZE: usize = 32;

    pub fn set(mut self, v: Vec<SocialKey>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: SocialKey) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = SocialKey>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }

    pub fn replace(&mut self, index: usize, v: SocialKey) -> Option<SocialKey> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SocialKeyVecBuilder {
    type Entity = SocialKeyVec;

    const NAME: &'static str = "SocialKeyVecBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SocialKeyVec::new_unchecked(inner.into())
    }
}
pub struct SocialKeyVecIterator(SocialKeyVec, usize, usize);
impl ::core::iter::Iterator for SocialKeyVecIterator {
    type Item = SocialKey;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SocialKeyVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SocialKeyVec {
    type IntoIter = SocialKeyVecIterator;
    type Item = SocialKey;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SocialKeyVecIterator(self, 0, len)
    }
}
impl<'r> SocialKeyVecReader<'r> {
    pub fn iter<'t>(&'t self) -> SocialKeyVecReaderIterator<'t, 'r> {
        SocialKeyVecReaderIterator(&self, 0, self.len())
    }
}
pub struct SocialKeyVecReaderIterator<'t, 'r>(&'t SocialKeyVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SocialKeyVecReaderIterator<'t, 'r> {
    type Item = SocialKeyReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SocialKeyVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SocialValueVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SocialValueVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SocialValueVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SocialValueVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for SocialValueVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        SocialValueVec::new_unchecked(v.into())
    }
}
impl SocialValueVec {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SocialValue> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SocialValue {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SocialValue::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SocialValue::new_unchecked(self.0.slice(start..end))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SocialValueVecReader<'r> {
        SocialValueVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SocialValueVec {
    type Builder = SocialValueVecBuilder;

    const NAME: &'static str = "SocialValueVec";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SocialValueVec(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialValueVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialValueVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct SocialValueVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SocialValueVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SocialValueVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SocialValueVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> SocialValueVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<SocialValueReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> SocialValueReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            SocialValueReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            SocialValueReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SocialValueVecReader<'r> {
    type Entity = SocialValueVec;

    const NAME: &'static str = "SocialValueVecReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SocialValueVecReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            SocialValueReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SocialValueVecBuilder(pub(crate) Vec<SocialValue>);
impl SocialValueVecBuilder {
    pub fn set(mut self, v: Vec<SocialValue>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: SocialValue) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = SocialValue>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }

    pub fn replace(&mut self, index: usize, v: SocialValue) -> Option<SocialValue> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for SocialValueVecBuilder {
    type Entity = SocialValueVec;

    const NAME: &'static str = "SocialValueVecBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SocialValueVec::new_unchecked(inner.into())
    }
}
pub struct SocialValueVecIterator(SocialValueVec, usize, usize);
impl ::core::iter::Iterator for SocialValueVecIterator {
    type Item = SocialValue;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for SocialValueVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for SocialValueVec {
    type IntoIter = SocialValueVecIterator;
    type Item = SocialValue;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        SocialValueVecIterator(self, 0, len)
    }
}
impl<'r> SocialValueVecReader<'r> {
    pub fn iter<'t>(&'t self) -> SocialValueVecReaderIterator<'t, 'r> {
        SocialValueVecReaderIterator(&self, 0, self.len())
    }
}
pub struct SocialValueVecReaderIterator<'t, 'r>(&'t SocialValueVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for SocialValueVecReaderIterator<'t, 'r> {
    type Item = SocialValueReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for SocialValueVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SocialEntries(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SocialEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SocialEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SocialEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "keys", self.keys())?;
        write!(f, ", {}: {}", "values", self.values())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SocialEntries {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        ];
        SocialEntries::new_unchecked(v.into())
    }
}
impl SocialEntries {
    pub const FIELD_COUNT: usize = 2;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn keys(&self) -> SocialKeyVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SocialKeyVec::new_unchecked(self.0.slice(start..end))
    }

    pub fn values(&self) -> SocialValueVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SocialValueVec::new_unchecked(self.0.slice(start..end))
        } else {
            SocialValueVec::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SocialEntriesReader<'r> {
        SocialEntriesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SocialEntries {
    type Builder = SocialEntriesBuilder;

    const NAME: &'static str = "SocialEntries";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SocialEntries(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialEntriesReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialEntriesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().keys(self.keys()).values(self.values())
    }
}
#[derive(Clone, Copy)]
pub struct SocialEntriesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SocialEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SocialEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SocialEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "keys", self.keys())?;
        write!(f, ", {}: {}", "values", self.values())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SocialEntriesReader<'r> {
    pub const FIELD_COUNT: usize = 2;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn keys(&self) -> SocialKeyVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SocialKeyVecReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn values(&self) -> SocialValueVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            SocialValueVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            SocialValueVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SocialEntriesReader<'r> {
    type Entity = SocialEntries;

    const NAME: &'static str = "SocialEntriesReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SocialEntriesReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SocialKeyVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        SocialValueVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SocialEntriesBuilder {
    pub(crate) keys:   SocialKeyVec,
    pub(crate) values: SocialValueVec,
}
impl SocialEntriesBuilder {
    pub const FIELD_COUNT: usize = 2;

    pub fn keys(mut self, v: SocialKeyVec) -> Self {
        self.keys = v;
        self
    }

    pub fn values(mut self, v: SocialValueVec) -> Self {
        self.values = v;
        self
    }
}
impl molecule::prelude::Builder for SocialEntriesBuilder {
    type Entity = SocialEntries;

    const NAME: &'static str = "SocialEntriesBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.keys.as_slice().len()
            + self.values.as_slice().len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.keys.as_slice().len();
        offsets.push(total_size);
        total_size += self.values.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.keys.as_slice())?;
        writer.write_all(self.values.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SocialEntries::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct FriendPubkey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FriendPubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FriendPubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FriendPubkey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "unlock_mode", self.unlock_mode())?;
        write!(f, ", {}: {}", "alg_index", self.alg_index())?;
        write!(f, ", {}: {}", "pubkey", self.pubkey())?;
        write!(f, ", {}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "ext_data", self.ext_data())?;
        write!(f, ", {}: {}", "subkey_proof", self.subkey_proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for FriendPubkey {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            47, 0, 0, 0, 28, 0, 0, 0, 29, 0, 0, 0, 31, 0, 0, 0, 35, 0, 0, 0, 39, 0, 0, 0, 43, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        FriendPubkey::new_unchecked(v.into())
    }
}
impl FriendPubkey {
    pub const FIELD_COUNT: usize = 6;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn unlock_mode(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte::new_unchecked(self.0.slice(start..end))
    }

    pub fn alg_index(&self) -> Uint16 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint16::new_unchecked(self.0.slice(start..end))
    }

    pub fn pubkey(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }

    pub fn signature(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }

    pub fn ext_data(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }

    pub fn subkey_proof(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> FriendPubkeyReader<'r> {
        FriendPubkeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FriendPubkey {
    type Builder = FriendPubkeyBuilder;

    const NAME: &'static str = "FriendPubkey";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FriendPubkey(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FriendPubkeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FriendPubkeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .unlock_mode(self.unlock_mode())
            .alg_index(self.alg_index())
            .pubkey(self.pubkey())
            .signature(self.signature())
            .ext_data(self.ext_data())
            .subkey_proof(self.subkey_proof())
    }
}
#[derive(Clone, Copy)]
pub struct FriendPubkeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FriendPubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FriendPubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FriendPubkeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "unlock_mode", self.unlock_mode())?;
        write!(f, ", {}: {}", "alg_index", self.alg_index())?;
        write!(f, ", {}: {}", "pubkey", self.pubkey())?;
        write!(f, ", {}: {}", "signature", self.signature())?;
        write!(f, ", {}: {}", "ext_data", self.ext_data())?;
        write!(f, ", {}: {}", "subkey_proof", self.subkey_proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> FriendPubkeyReader<'r> {
    pub const FIELD_COUNT: usize = 6;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn unlock_mode(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        ByteReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn alg_index(&self) -> Uint16Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint16Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn pubkey(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn signature(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn ext_data(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn subkey_proof(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FriendPubkeyReader<'r> {
    type Entity = FriendPubkey;

    const NAME: &'static str = "FriendPubkeyReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        FriendPubkeyReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        ByteReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint16Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        BytesReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FriendPubkeyBuilder {
    pub(crate) unlock_mode:  Byte,
    pub(crate) alg_index:    Uint16,
    pub(crate) pubkey:       Bytes,
    pub(crate) signature:    Bytes,
    pub(crate) ext_data:     Uint32,
    pub(crate) subkey_proof: Bytes,
}
impl FriendPubkeyBuilder {
    pub const FIELD_COUNT: usize = 6;

    pub fn unlock_mode(mut self, v: Byte) -> Self {
        self.unlock_mode = v;
        self
    }

    pub fn alg_index(mut self, v: Uint16) -> Self {
        self.alg_index = v;
        self
    }

    pub fn pubkey(mut self, v: Bytes) -> Self {
        self.pubkey = v;
        self
    }

    pub fn signature(mut self, v: Bytes) -> Self {
        self.signature = v;
        self
    }

    pub fn ext_data(mut self, v: Uint32) -> Self {
        self.ext_data = v;
        self
    }

    pub fn subkey_proof(mut self, v: Bytes) -> Self {
        self.subkey_proof = v;
        self
    }
}
impl molecule::prelude::Builder for FriendPubkeyBuilder {
    type Entity = FriendPubkey;

    const NAME: &'static str = "FriendPubkeyBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.unlock_mode.as_slice().len()
            + self.alg_index.as_slice().len()
            + self.pubkey.as_slice().len()
            + self.signature.as_slice().len()
            + self.ext_data.as_slice().len()
            + self.subkey_proof.as_slice().len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.unlock_mode.as_slice().len();
        offsets.push(total_size);
        total_size += self.alg_index.as_slice().len();
        offsets.push(total_size);
        total_size += self.pubkey.as_slice().len();
        offsets.push(total_size);
        total_size += self.signature.as_slice().len();
        offsets.push(total_size);
        total_size += self.ext_data.as_slice().len();
        offsets.push(total_size);
        total_size += self.subkey_proof.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.unlock_mode.as_slice())?;
        writer.write_all(self.alg_index.as_slice())?;
        writer.write_all(self.pubkey.as_slice())?;
        writer.write_all(self.signature.as_slice())?;
        writer.write_all(self.ext_data.as_slice())?;
        writer.write_all(self.subkey_proof.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FriendPubkey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct FriendPubkeyVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FriendPubkeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FriendPubkeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FriendPubkeyVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for FriendPubkeyVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        FriendPubkeyVec::new_unchecked(v.into())
    }
}
impl FriendPubkeyVec {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<FriendPubkey> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> FriendPubkey {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            FriendPubkey::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            FriendPubkey::new_unchecked(self.0.slice(start..end))
        }
    }

    pub fn as_reader<'r>(&'r self) -> FriendPubkeyVecReader<'r> {
        FriendPubkeyVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FriendPubkeyVec {
    type Builder = FriendPubkeyVecBuilder;

    const NAME: &'static str = "FriendPubkeyVec";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FriendPubkeyVec(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FriendPubkeyVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FriendPubkeyVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct FriendPubkeyVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FriendPubkeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FriendPubkeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FriendPubkeyVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> FriendPubkeyVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn len(&self) -> usize {
        self.item_count()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn get(&self, idx: usize) -> Option<FriendPubkeyReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }

    pub fn get_unchecked(&self, idx: usize) -> FriendPubkeyReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            FriendPubkeyReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            FriendPubkeyReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FriendPubkeyVecReader<'r> {
    type Entity = FriendPubkeyVec;

    const NAME: &'static str = "FriendPubkeyVecReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        FriendPubkeyVecReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            FriendPubkeyReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FriendPubkeyVecBuilder(pub(crate) Vec<FriendPubkey>);
impl FriendPubkeyVecBuilder {
    pub fn set(mut self, v: Vec<FriendPubkey>) -> Self {
        self.0 = v;
        self
    }

    pub fn push(mut self, v: FriendPubkey) -> Self {
        self.0.push(v);
        self
    }

    pub fn extend<T: ::core::iter::IntoIterator<Item = FriendPubkey>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }

    pub fn replace(&mut self, index: usize, v: FriendPubkey) -> Option<FriendPubkey> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for FriendPubkeyVecBuilder {
    type Entity = FriendPubkeyVec;

    const NAME: &'static str = "FriendPubkeyVecBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FriendPubkeyVec::new_unchecked(inner.into())
    }
}
pub struct FriendPubkeyVecIterator(FriendPubkeyVec, usize, usize);
impl ::core::iter::Iterator for FriendPubkeyVecIterator {
    type Item = FriendPubkey;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for FriendPubkeyVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for FriendPubkeyVec {
    type IntoIter = FriendPubkeyVecIterator;
    type Item = FriendPubkey;

    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        FriendPubkeyVecIterator(self, 0, len)
    }
}
impl<'r> FriendPubkeyVecReader<'r> {
    pub fn iter<'t>(&'t self) -> FriendPubkeyVecReaderIterator<'t, 'r> {
        FriendPubkeyVecReaderIterator(&self, 0, self.len())
    }
}
pub struct FriendPubkeyVecReaderIterator<'t, 'r>(&'t FriendPubkeyVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for FriendPubkeyVecReaderIterator<'t, 'r> {
    type Item = FriendPubkeyReader<'t>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for FriendPubkeyVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct SocialUnlockEntries(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SocialUnlockEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SocialUnlockEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SocialUnlockEntries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "social_value", self.social_value())?;
        write!(f, ", {}: {}", "social_proof", self.social_proof())?;
        write!(f, ", {}: {}", "social_friends", self.social_friends())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SocialUnlockEntries {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            51, 0, 0, 0, 16, 0, 0, 0, 43, 0, 0, 0, 47, 0, 0, 0, 27, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0,
            0, 22, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        ];
        SocialUnlockEntries::new_unchecked(v.into())
    }
}
impl SocialUnlockEntries {
    pub const FIELD_COUNT: usize = 3;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn social_value(&self) -> SocialValue {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SocialValue::new_unchecked(self.0.slice(start..end))
    }

    pub fn social_proof(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }

    pub fn social_friends(&self) -> FriendPubkeyVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            FriendPubkeyVec::new_unchecked(self.0.slice(start..end))
        } else {
            FriendPubkeyVec::new_unchecked(self.0.slice(start..))
        }
    }

    pub fn as_reader<'r>(&'r self) -> SocialUnlockEntriesReader<'r> {
        SocialUnlockEntriesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SocialUnlockEntries {
    type Builder = SocialUnlockEntriesBuilder;

    const NAME: &'static str = "SocialUnlockEntries";

    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SocialUnlockEntries(data)
    }

    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }

    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }

    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialUnlockEntriesReader::from_slice(slice).map(|reader| reader.to_entity())
    }

    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SocialUnlockEntriesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }

    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }

    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .social_value(self.social_value())
            .social_proof(self.social_proof())
            .social_friends(self.social_friends())
    }
}
#[derive(Clone, Copy)]
pub struct SocialUnlockEntriesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SocialUnlockEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SocialUnlockEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SocialUnlockEntriesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "social_value", self.social_value())?;
        write!(f, ", {}: {}", "social_proof", self.social_proof())?;
        write!(f, ", {}: {}", "social_friends", self.social_friends())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SocialUnlockEntriesReader<'r> {
    pub const FIELD_COUNT: usize = 3;

    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }

    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }

    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }

    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }

    pub fn social_value(&self) -> SocialValueReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        SocialValueReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn social_proof(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }

    pub fn social_friends(&self) -> FriendPubkeyVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            FriendPubkeyVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            FriendPubkeyVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SocialUnlockEntriesReader<'r> {
    type Entity = SocialUnlockEntries;

    const NAME: &'static str = "SocialUnlockEntriesReader";

    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }

    fn new_unchecked(slice: &'r [u8]) -> Self {
        SocialUnlockEntriesReader(slice)
    }

    fn as_slice(&self) -> &'r [u8] {
        self.0
    }

    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        SocialValueReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        FriendPubkeyVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SocialUnlockEntriesBuilder {
    pub(crate) social_value:   SocialValue,
    pub(crate) social_proof:   Bytes,
    pub(crate) social_friends: FriendPubkeyVec,
}
impl SocialUnlockEntriesBuilder {
    pub const FIELD_COUNT: usize = 3;

    pub fn social_value(mut self, v: SocialValue) -> Self {
        self.social_value = v;
        self
    }

    pub fn social_proof(mut self, v: Bytes) -> Self {
        self.social_proof = v;
        self
    }

    pub fn social_friends(mut self, v: FriendPubkeyVec) -> Self {
        self.social_friends = v;
        self
    }
}
impl molecule::prelude::Builder for SocialUnlockEntriesBuilder {
    type Entity = SocialUnlockEntries;

    const NAME: &'static str = "SocialUnlockEntriesBuilder";

    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.social_value.as_slice().len()
            + self.social_proof.as_slice().len()
            + self.social_friends.as_slice().len()
    }

    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.social_value.as_slice().len();
        offsets.push(total_size);
        total_size += self.social_proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.social_friends.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.social_value.as_slice())?;
        writer.write_all(self.social_proof.as_slice())?;
        writer.write_all(self.social_friends.as_slice())?;
        Ok(())
    }

    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SocialUnlockEntries::new_unchecked(inner.into())
    }
}
